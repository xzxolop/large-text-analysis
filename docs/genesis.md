## Описание

Наиболее актуальный код содержится в директории ./console-demo

Для поиска слов в предложениях реализован InvertedIndex.
Для загрузки, хранения и преобразования датасета в список предложений реализован DataStorage.

В качестве основного контейнера для хранения предложений и передачи из DataStorage в InvertedIndex используются списки.

## Флоу программы
Пока-что программа работает только для английски

### class DataStorage

Для хранения использует стратегию "4 списка", 3 трех из которых хранится текст и предложения, а 4 это список связей.

Для загрузки датасета используется функция load_data, которая загружает датасет реддита (пока что захардкоженно). 

Далее происходит обработка текста. Комментарии разбиваются на предложения, а из предложений удаляются стоп слова. 
[t1, t2, t3] -> [s1, s2, s3, s4, s5] -> [s1', s2', s3', s4', s5']
[0, 0, 1, 2, 2] - писок связей, где index соответствует оригинальному и обработаному предожению а value - документу датасета.

В ходе работы функции загружается датасет и заполняются списки.

Класс предоставляет всевозможные функции для работы с предложениями.

### class InvertedIndex

### Алгоритмическая сложность

Тесты проводились на процессоре ryzen 5 2600 + 32gb ddr4

1. Загрузка данных `load_data`
Загрузка датасета с kagglehub - зависет от интернета ~ 1.5 сек.

Заполнение списков (`__fill_lists_by_main_text`) 

Сложность O(n^3)
первый for - разбиваем на предожения;
второй for - разбиаем на слова;
третий for - удаление лишних слов;
Время выполнения ~ 13.63 секунд.

2. Создание списка `__init__`

Заполение инвертированного индекса (`create_index`)

Сложность O(n^2)
первый for - разбиения на слова;
второй for - заполнение инвертированного индекса;
Время выполнения ~ 6.13 секунд.

Заполнение списка частот слов (`__topOfIndex`). Вызывается если поднят флаг (`calc_word_freq`)

Сложность O(n)
единственный for - для итерации по индексу
Время выполнения ~ 0.099 секунд.

3. Поиск с историей `searchWith`
Сам поиск 
Если ищем в первый раз или слово не найдено - O(1)
Если ищем последовательно (два и более слова) - O(n)

Вычисление частоты всречаемости слов `calculate_frequency`
Получение предложений в которых встречается исходное слово (`get_sentences_by_indexes`) - O(n).
На их основе формируем инвертированный индекс (`create_index`) - O(n^2)
Заполнение списка частот слов (`__topOfIndex`) - O(n)
Итого: O(n^2) + O(2*n) = O(n^2)

Время выполнения для наиболее популярных слов:
data  - 1.1194 
use   - 1.0995
get   - 0.0990
I     - 0.0133
you   - 0.0032

### Планы на будущее

1. Сжать круг поиска до контекстного окна в рамка одного предлоения. Для этого необходимо работать с коллакациями, n-gramm.
2. Разбивать предложения как дерево с кластерами ввиде узлов. Слова должны часто встречаться в этом класстере и редко в других.
3. Убрать постоянную загрузку датасета, если он уже был загружен.
4. Может быть заменить list на другой контейнер.
5. Нужно проверить в тестах, что инварианты __searched_words и __searched_sentences корректны.
6. При обработке предложений удалять ссылки и прочую фигню, capitalize

